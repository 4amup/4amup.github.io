{"meta":{"title":"Iron Man","subtitle":null,"description":null,"author":"李晓春","url":"https://wozhizui.github.io"},"pages":[],"posts":[{"title":"事件捕获和事件冒泡原理图","slug":"事件捕获和事件冒泡原理图","date":"2017-06-01T07:08:59.000Z","updated":"2018-02-12T09:28:38.997Z","comments":true,"path":"2017/06/01/事件捕获和事件冒泡原理图/","link":"","permalink":"https://wozhizui.github.io/2017/06/01/事件捕获和事件冒泡原理图/","excerpt":"","text":"","categories":[{"name":"图","slug":"图","permalink":"https://wozhizui.github.io/categories/图/"}],"tags":[{"name":"事件","slug":"事件","permalink":"https://wozhizui.github.io/tags/事件/"}]},{"title":"NodeList的非数组性和有时实时性","slug":"NodeList的非数组性和有时实时性","date":"2017-05-25T07:54:23.000Z","updated":"2018-02-12T09:27:45.192Z","comments":true,"path":"2017/05/25/NodeList的非数组性和有时实时性/","link":"","permalink":"https://wozhizui.github.io/2017/05/25/NodeList的非数组性和有时实时性/","excerpt":"最近在重新复习以前学过的课程，大部分是基础的东西。 《JavaScript DOM 编程艺术》是一本经典的JavaScript入门书。去年年初怀着无线的憧憬刷过一遍，奈何后来买新房装修，耽误了大半年的时间，旧的知识不知不觉就忘了。 今年重整旗鼓，本来想直接看新书的，但做一些小项目经常出现基础不牢的情况。于是重走长征路，看过的书再刷一遍，做过的项目，用新技术重构一遍。 过去的一年node.js发展迅猛，去年哈尔滨应用这个技术的公司还相对较少，大部分都是PHP。今年以来，发现有了一些改变。加油吧，年轻人们。 闲言够了，接下来写写最近重新复习《JavaScript DOM 编程艺术》时重新归纳的一个小知识点吧，真的是基础中的基础。","text":"最近在重新复习以前学过的课程，大部分是基础的东西。 《JavaScript DOM 编程艺术》是一本经典的JavaScript入门书。去年年初怀着无线的憧憬刷过一遍，奈何后来买新房装修，耽误了大半年的时间，旧的知识不知不觉就忘了。 今年重整旗鼓，本来想直接看新书的，但做一些小项目经常出现基础不牢的情况。于是重走长征路，看过的书再刷一遍，做过的项目，用新技术重构一遍。 过去的一年node.js发展迅猛，去年哈尔滨应用这个技术的公司还相对较少，大部分都是PHP。今年以来，发现有了一些改变。加油吧，年轻人们。 闲言够了，接下来写写最近重新复习《JavaScript DOM 编程艺术》时重新归纳的一个小知识点吧，真的是基础中的基础。 一、非数组特性以下内容引用MDN，这也是关于原生JavaScript最好的官方文档，没有之一。 为什么 NodeList 不是数组？ NodeList 对象在某些方面和数组非常相似，看上去可以直接使用从 Array.prototype 上继承的方法。然而，NodeList 没有这些类似数组的方法。 JavaScript 的继承机制是基于原型的。数组元素之所以有一些数组方法（比如 forEach 和 map），是因为它的原型链上有这些方法，如下: myArray –&gt; Array.prototype –&gt; Object.prototype –&gt; null (想要获取一个对象的原型链，可以连续的调用 Object.getPrototypeOf，直到原型链尽头). forEach, map这些方式其实是 Array.prototype 这个对象的方法。 和数组不一样，NodeList的原型链是这样的： myNodeList –&gt; NodeList.prototype –&gt; Object.prototype –&gt; null NodeList.prototype 只有一个 item 方法，没有 Array.prototype 上的那些方法，所以 NodeList 对象用不了它们。 NodeList不是数组，这出乎我的意料。所以一定要记住，forEach、filter、map和reduce等方法就都不能用了，实际写代码要记住这个区别。 当然可以通过原型链的方式扩展forEach，不过官方不推荐。 扩展DOM对象的原型 1234567891011121314151617var arrayMethods = Object.getOwnPropertyNames( Array.prototype );arrayMethods.forEach( attachArrayMethodsToNodeList );function attachArrayMethodsToNodeList(methodName)&#123; if(methodName !== \"length\") &#123; NodeList.prototype[methodName] = Array.prototype[methodName]; &#125;&#125;;var divs = document.getElementsByTagName( 'div' );var firstDiv = divs[ 0 ];firstDiv.childNodes.forEach(function( divChild )&#123; divChild.parentNode.style.color = '#0F0';&#125;); 不扩展DOM对象的原型 12345678var forEach = Array.prototype.forEach;var divs = document.getElementsByTagName( 'div' );var firstDiv = divs[ 0 ];forEach.call(firstDiv.childNodes, function( divChild )&#123; divChild.parentNode.style.color = '#0F0';&#125;); 二、有时实时大多数情况下，NodeList 对象都是个实时集合。意思是说，如果文档中的节点树发生变化，则已经存在的 NodeList 对象也可能会变化。例如，Node.childNodes 是实时的： 12345var parent = document.getElementById('parent');var child_nodes = parent.childNodes;console.log(child_nodes.length); // 如果假设结果是“2”parent.appendChild(document.createElement('div'));console.log(child_nodes.length); // 此时的输出是“3” 在另一些情况下，NodeList 是一个静态集合，也就意味着随后对文档对象模型的任何改动都不会影响集合的内容。document.querySelectorAll 返回一个静态的 NodeList。 特别是当你选择如何遍历 NodeList 中所有项，或缓存列表长度的时候，最好牢记这种区分。 原文链接","categories":[],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://wozhizui.github.io/tags/DOM/"},{"name":"NodeList","slug":"NodeList","permalink":"https://wozhizui.github.io/tags/NodeList/"}]},{"title":"乱乱的原型链图","slug":"乱乱的原型链图","date":"2017-05-16T03:30:58.000Z","updated":"2018-02-12T09:30:25.378Z","comments":true,"path":"2017/05/16/乱乱的原型链图/","link":"","permalink":"https://wozhizui.github.io/2017/05/16/乱乱的原型链图/","excerpt":"","text":"Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 这个图分类，左实例，中构造函数，右原型。","categories":[],"tags":[{"name":"原型链","slug":"原型链","permalink":"https://wozhizui.github.io/tags/原型链/"}]},{"title":"html、css和js加载顺序","slug":"html、css和js加载顺序","date":"2017-05-15T08:40:41.000Z","updated":"2018-02-12T09:29:12.665Z","comments":true,"path":"2017/05/15/html、css和js加载顺序/","link":"","permalink":"https://wozhizui.github.io/2017/05/15/html、css和js加载顺序/","excerpt":"HTML页面加载和解析流程，探究本源","text":"HTML页面加载和解析流程，探究本源 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件。 浏览器开始载入html代码，发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件。 浏览器又发出CSS文件的请求，服务器返回这个CSS文件。 浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了。 浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码。 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码。 浏览器发现了一个包含一行Javascript代码的&lt;script&gt;标签，赶快运行它。 Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;style&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码。 终于等到了&lt;/html&gt;的到来，浏览器泪流满面…… 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径。 浏览器召集了在座的各位&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 总结： 总的来说就是按照html文档的顺序加载 还有就是最好将无论内部或是外部JS文件放到所有html内容之后，这样会令用户感觉页面加载速度变快了，否则如果将所有外部文件（包括css和JS）引用都放到&lt;head&gt;中，意味着必须等到全部的JS代码都被下载解析和执行完毕后，才能开始呈现页面的内容（当浏览器遇到&lt;body&gt;）,这样会导致呈现页面时出现明显的延迟，二延迟期间的浏览器窗口将是一片空白。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://wozhizui.github.io/tags/网络/"},{"name":"html","slug":"html","permalink":"https://wozhizui.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://wozhizui.github.io/tags/css/"},{"name":"js","slug":"js","permalink":"https://wozhizui.github.io/tags/js/"}]},{"title":"理解同步与异步","slug":"理解同步和异步","date":"2017-05-07T01:09:43.000Z","updated":"2018-02-12T09:29:28.278Z","comments":true,"path":"2017/05/07/理解同步和异步/","link":"","permalink":"https://wozhizui.github.io/2017/05/07/理解同步和异步/","excerpt":"作者：严肃链接：https://www.zhihu.com/question/19732473/answer/20851256来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。","text":"作者：严肃链接：https://www.zhihu.com/question/19732473/answer/20851256来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 “阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，提供一个从分布式系统角度的回答。1.同步与异步同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。2. 阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。 如果是关心blocking IO/ asynchronous IO, 参考 Unix Network Programming View Book","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://wozhizui.github.io/categories/学习笔记/"}],"tags":[{"name":"同步","slug":"同步","permalink":"https://wozhizui.github.io/tags/同步/"},{"name":"异步","slug":"异步","permalink":"https://wozhizui.github.io/tags/异步/"}]}]}